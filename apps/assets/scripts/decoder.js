// Generated by CoffeeScript 1.12.7
  var api, decodeJPEG, decodeRaw, engine, getImageData, onmessage, pixelValue, update, wasm_update;

  importScripts('wvnc_asm.js');

  importScripts('pako.min.js');

  importScripts('jpeg-decoder.js');

  api = {};

  engine = void 0;

  Module.onRuntimeInitialized = function() {
    return api = {
      createBuffer: Module.cwrap('create_buffer', 'number', ['number', 'number']),
      destroyBuffer: Module.cwrap('destroy_buffer', '', ['number']),
      updateBuffer: Module.cwrap("update", 'number', ['number', 'number', 'number', 'number', 'number', 'number']),
      decodeBuffer: Module.cwrap("decode", 'number', ['number', 'number', 'number', 'number'])
    };
  };

  pixelValue = function(value, depth) {
    var pixel;
    pixel = {
      r: 255,
      g: 255,
      b: 255,
      a: 255
    };
    if (depth === 24 || depth === 32) {
      pixel.r = value & 0xFF;
      pixel.g = (value >> 8) & 0xFF;
      pixel.b = (value >> 16) & 0xFF;
    } else if (depth === 16) {
      pixel.r = (value & 0x1F) * (255 / 31);
      pixel.g = ((value >> 5) & 0x3F) * (255 / 63);
      pixel.b = ((value >> 11) & 0x1F) * (255 / 31);
    }
    return pixel;
  };

  getImageData = function(d) {
    var data, i, j, k, l, npixels, pixel, ref, ref1, step, value;
    if (engine.depth === 32) {
      return d.pixels;
    }
    step = engine.depth / 8;
    npixels = d.pixels.length / step;
    data = new Uint8ClampedArray(d.w * d.h * 4);
    for (i = k = 0, ref = npixels - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      value = 0;
      for (j = l = 0, ref1 = step - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
        value = value | d.pixels[i * step + j] << (j * 8);
      }
      pixel = pixelValue(value, engine.depth);
      data[i * 4] = pixel.r;
      data[i * 4 + 1] = pixel.g;
      data[i * 4 + 2] = pixel.b;
      data[i * 4 + 3] = pixel.a;
    }
    return data;
  };

  decodeRaw = function(d) {
    d.pixels = getImageData(d);
    return d;
  };

  decodeJPEG = function(d) {
    var raw;
    raw = decode(d.pixels, {
      useTArray: true,
      colorTransform: true
    });
    d.pixels = raw.data;
    return d;

    /*
    blob = new Blob [d.pixels], { type: "image/jpeg" }
    reader = new FileReader()
    reader.onloadend = () ->
        d.pixels = reader.result
        postMessage d
    reader.readAsDataURL blob
     */
  };

  update = function(msg) {
    var d, data, raw;
    d = {};
    data = new Uint8Array(msg);
    d.x = data[1] | (data[2] << 8);
    d.y = data[3] | (data[4] << 8);
    d.w = data[5] | (data[6] << 8);
    d.h = data[7] | (data[8] << 8);
    d.flag = data[9];
    d.pixels = data.subarray(10);
    switch (d.flag) {
      case 0x0:
        raw = decodeRaw(d);
        break;
      case 0x1:
        raw = decodeJPEG(d);
        break;
      case 0x2:
        d.pixels = pako.inflate(d.pixels);
        raw = decodeRaw(d);
        break;
      case 0x3:
        d.pixels = pako.inflate(d.pixels);
        raw = decodeJPEG(d);
    }
    if (!raw) {
      return;
    }
    raw.pixels = raw.pixels.buffer;
    return postMessage(raw, [raw.pixels]);
  };

  wasm_update = function(msg) {
    var datain, dataout, flag, h, p, po, size, tmp, w, x, y;
    datain = new Uint8Array(msg);
    x = datain[1] | (datain[2] << 8);
    y = datain[3] | (datain[4] << 8);
    w = datain[5] | (datain[6] << 8);
    h = datain[7] | (datain[8] << 8);
    flag = datain[9];
    p = api.createBuffer(datain.length);
    Module.HEAP8.set(datain, p);
    size = w * h * 4;
    po = api.decodeBuffer(p, datain.length, engine.depth, size);
    dataout = new Uint8Array(Module.HEAP8.buffer, po, size);
    msg = {};
    tmp = new Uint8Array(size);
    tmp.set(dataout, 0);
    msg.pixels = tmp.buffer;
    msg.x = x;
    msg.y = y;
    msg.w = w;
    msg.h = h;
    postMessage(msg, [msg.pixels]);
    api.destroyBuffer(p);
    if (flag !== 0x0 || engine.depth !== 32) {
      return api.destroyBuffer(po);
    }
  };

  onmessage = function(e) {
    if (e.data.depth) {
      return engine = e.data;
    } else {
      if (engine.wasm) {
        return wasm_update(e.data);
      }
      return update(e.data);
    }
  };

